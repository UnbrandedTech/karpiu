import numpy as np
from typing import Optional


def make_trend(
    n_steps: int,
    rw_loc: float = 0.0,
    rw_scale: float = 0.1,
    seed: Optional[int] = None,
) -> np.array:
    """Generate time-series trend with different methods.

    Args:
        n_steps: Total steps of series
        rw_loc: Location parameter of random walk generated by `np.random.normal()`
        rw_scale: Scale parameter of random walk generated by `np.random.normal()`
        seed: Seed passed into `np.random.default_rng()`

    Returns:
        Simulated trend with length equals `series_len`

    """
    if seed is not None:
        np.random.seed(seed)
    # make trend
    rw = np.random.default_rng(seed).normal(rw_loc, rw_scale, n_steps)
    trend = np.cumsum(rw)

    return trend


def make_seasonality(
    n_steps: int,
    seasonality: float,
    order: int = 3,
    scale: float = 0.05,
    seed: Optional[int] = None,
) -> np.array:
    """Generate time-series seasonality with different

    Args:
        n_steps: Total steps of series
        seasonality: For example, a weekly series would use seasonality=52
        order: Fourier series order to generate seasonality.
        scale: Scale parameter of seasonality generation by Normal(0, scale).
            When method = 'discrete', it is directly used.
            when method = 'fourier', it is used to multiply with the sin-cosine wave generated series.
        seed: Seed passed into `np.random.default_rng()`

    Returns:
        Simulated seasonal time-series

    Notes
    -----
      1. In case of method = 'discrete', only `seasonality - 1` variables will be generated and the rest is
      directly derived to preserve the property of the sum of seasonality equals 1.
      2. In case of method = 'fourier', see https://otexts.com/fpp2/complexseasonality.html
    """
    if seed is not None:
        np.random.seed(seed)
    if seasonality > 1:
        t = np.arange(0, n_steps)
        out = []
        for i in range(1, order + 1):
            x = 2.0 * i * np.pi * t / seasonality
            out.append(np.sin(x))
            out.append(np.cos(x))
        out = np.column_stack(out)
        b = np.random.default_rng(seed).normal(0, scale, order * 2)
        seas = np.matmul(out, b)
    else:
        seas = np.zeros(n_steps)

    return seas


def make_features(
    n_obs: int,
    loc: np.array,
    scale: np.array,
    sparsity: float = 0.0,
    seed: Optional[int] = None,
) -> np.array:
    """Generate features for data simulation

    Args:
        n_obs:
        loc:
        scale:
        sparsity: 0 to 1 to control probability (= 1 - sparsity) at time t of a regressor value > 0
        seed:

    Returns:
        simulated data 2-D array
    """
    if (len(loc.shape) > 2) or (len(scale.shape) > 2):
        raise Exception("Dimension error for loc or scale.")

    if len(loc) != len(scale):
        raise Exception("loc and scale length not equal.")

    if seed is not None:
        np.random.seed(seed)

    n_feat = len(loc)

    # broadcast
    x = np.random.normal(loc.reshape(1, -1), scale.reshape(1, -1), size=(n_obs, n_feat))

    # control probability of regression kick-in
    if (sparsity > 0.0) and (sparsity < 1.0):
        z = np.random.binomial(1, 1 - sparsity, n_obs * n_feat).reshape(n_obs, -1)
        x = x * z

    return x


def make_regression(
    x: np.array,
    coefs: np.array,
    bias: float = 0.0,
    noise_scale: float = 1.0,
    relevance: float = 1.0,
    seed: Optional[int] = None,
) -> np.array:
    """Generate regression components for paid marketing

    Args:
        x: regressors / features values; first dimension represents observations
        coefs: Values used as regression coefficients
        noise_scale:  Scale parameter in the white noise generation process
        bias: bias or intercept of the regression component; if None, bias is set to zero.
        relevance: 0 to 1; smaller value indicates smaller total number of useful regressor
        seed: Seed passed into `np.random.default_rng()`

    Returns
        x: Regressors simulated array. Should be with shape (series_len, num_of_regressors);
        y: Regression derived by product of X and coefficients plus noise
        coefs: Coefficients modified in the process due to sparsity; if sparsity=0,
        it should be identical to coefs input by user
    """
    if len(x.shape) != 2:
        raise Exception("x must be a 2-dimensions array.")

    n_obs, num_of_regressors = x.shape

    if seed is not None:
        np.random.seed(seed)

    if (relevance > 0.0) and (relevance < 1.0):
        num_of_irr_coefs = int(num_of_regressors * (1 - relevance))
        coefs = np.copy(coefs)
        irr_idx = np.random.choice(num_of_regressors, num_of_irr_coefs, replace=False)
        coefs[irr_idx] = 0.0

    noise = np.random.normal(0, noise_scale, n_obs)

    # make observed response
    if bias:
        y = bias + np.matmul(x, coefs) + noise
    else:
        y = np.matmul(x, coefs) + noise

    return y
