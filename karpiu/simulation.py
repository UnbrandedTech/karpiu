import numpy as np
from typing import Optional


def make_trend(
    n_steps: int,
    rw_loc: float = 0.0,
    rw_scale: float = 0.1,
    seed: int = 2022,
) -> np.array:
    """Generate time-series trend with different methods.

    Args:
        n_steps: Total steps of series
        rw_loc: Location parameter of random walk generated by `np.random.normal()`
        rw_scale: Scale parameter of random walk generated by `np.random.normal()`
        seed: Seed passed into `np.random.default_rng()`

    Returns:
        Simulated trend with length equals `series_len`

    """
    # make trend
    rw = np.random.default_rng(seed).normal(rw_loc, rw_scale, n_steps)
    trend = np.cumsum(rw)

    return trend


def make_seasonality(
    n_steps: int,
    seasonality: float,
    order: int = 3,
    scale: float = 0.05,
    seed: int = 2022,
) -> np.array:
    """Generate time-series seasonality with different

    Args:
        n_steps: Total steps of series
        seasonality: For example, a weekly series would use seasonality=52
        order: Fourier series order to generate seasonality.
        scale: Scale parameter of seasonality generation by Normal(0, scale).
            When method = 'discrete', it is directly used.
            when method = 'fourier', it is used to multiply with the sin-cosine wave generated series.
        seed: Seed passed into `np.random.default_rng()`

    Returns:
        Simulated seasonal time-series

    Notes
    -----
      1. In case of method = 'discrete', only `seasonality - 1` variables will be generated and the rest is
      directly derived to preserve the property of the sum of seasonality equals 1.
      2. In case of method = 'fourier', see https://otexts.com/fpp2/complexseasonality.html
    """
    if seasonality > 1:
        t = np.arange(0, n_steps)
        out = []
        for i in range(1, order + 1):
            x = 2.0 * i * np.pi * t / seasonality
            out.append(np.sin(x))
            out.append(np.cos(x))
        out = np.column_stack(out)
        b = np.random.default_rng(seed).normal(0, scale, order * 2)
        seas = np.matmul(out, b)
    else:
        seas = np.zeros(n_steps)

    return seas


def make_regression(
    n_steps: int,
    coefs: list[float],
    loc: float = 0,
    scale: float = 0.5,
    cov: Optional[np.array] = None,
    noise_scale: float = 1.0,
    bias: float = 0.0,
    relevance: float = 1.0,
    sparsity: float = 0.2,
    seed: int = 2022,
) -> np.array:
    """Generate regression components

    Args:
        n_steps: Total length of series
        coefs: Values used as regression coefficients
        loc: Location parameter to generate regressor values
        scale: Scale parameter to generate regressor values
        cov: Covariance of regressors; need to be positive definite
        noise_scale:  Scale parameter in the white noise generation process
        bias: bias or intercept of the regression component; if None, bias is set to zero.
        relevance: 0 to 1; smaller value indicates smaller total number of useful regressor
        sparsity: 0 to 1 to control probability (= 1 - sparsity) at time t of a regressor value > 0
        seed: Seed passed into `np.random.default_rng()`

    Returns
        x: Regressors simulated array. Should be with shape (series_len, num_of_regressors);
        y: Regression derived by product of X and coefficients plus noise
        coefs: Coefficients modified in the process due to sparsity; if sparsity=0,
        it should be identical to coefs input by user
    """

    num_of_regressors = len(coefs)
    if (relevance > 0.0) and (relevance < 1.0):
        num_of_irr_coefs = int(num_of_regressors * (1 - relevance))
        coefs = np.copy(coefs)
        irr_idx = np.random.choice(num_of_regressors, num_of_irr_coefs, replace=False)
        coefs[irr_idx] = 0.0

    if cov is None:
        x = (
            np.random.default_rng(seed)
            .normal(loc, scale, n_steps * num_of_regressors)
            .reshape(n_steps, -1)
        )
    else:
        x = np.random.default_rng(seed).multivariate_normal(
            np.array([loc] * num_of_regressors, dtype=np.float64), cov, n_steps
        )
    # control probability of regression kick-in
    if (sparsity > 0.0) and (sparsity < 1.0):
        z = (
            np.random.default_rng(seed)
            .binomial(1, 1 - sparsity, n_steps * num_of_regressors)
            .reshape(n_steps, -1)
        )
        x = x * z

    noise = np.random.default_rng(seed).normal(0, noise_scale, n_steps)
    # make observed response
    if bias:
        y = bias + np.matmul(x, coefs) + noise
    else:
        y = np.matmul(x, coefs) + noise

    return x, y, coefs
